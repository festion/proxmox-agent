#!/usr/bin/env python3
"""
High Priority Optimization Implementation Tool
Implements critical optimizations identified in the environment audit
"""

import os
import sys
import json
import asyncio
import aiohttp
import ssl
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

class HighPriorityOptimizations:
    def __init__(self):
        self.host = os.getenv('PROXMOX_HOST')
        self.port = os.getenv('PROXMOX_PORT', '8006')
        self.username = os.getenv('PROXMOX_USERNAME')
        self.password = os.getenv('PROXMOX_PASSWORD')
        self.realm = os.getenv('PROXMOX_REALM', 'pam')
        self.verify_ssl = os.getenv('PROXMOX_VERIFY_SSL', 'false').lower() == 'true'
        self.timeout = int(os.getenv('PROXMOX_TIMEOUT', '30'))
        
        self.base_url = f"https://{self.host}:{self.port}/api2/json"
        self.session = None
        self.ticket = None
        self.csrf_token = None
        self.node_name = "proxmox"
        
    async def create_session(self):
        """Create aiohttp session with SSL configuration"""
        ssl_context = ssl.create_default_context()
        if not self.verify_ssl:
            ssl_context.check_hostname = False
            ssl_context.verify_mode = ssl.CERT_NONE
            
        connector = aiohttp.TCPConnector(ssl=ssl_context)
        timeout = aiohttp.ClientTimeout(total=self.timeout)
        self.session = aiohttp.ClientSession(connector=connector, timeout=timeout)
        
    async def authenticate(self):
        """Authenticate with Proxmox API"""
        auth_data = {
            'username': f"{self.username}@{self.realm}",
            'password': self.password
        }
        
        try:
            async with self.session.post(f"{self.base_url}/access/ticket", data=auth_data) as response:
                if response.status == 200:
                    result = await response.json()
                    self.ticket = result['data']['ticket']
                    self.csrf_token = result['data']['CSRFPreventionToken']
                    
                    self.session.headers.update({
                        'Cookie': f'PVEAuthCookie={self.ticket}',
                        'CSRFPreventionToken': self.csrf_token
                    })
                    return True
                else:
                    print(f"‚ùå Authentication failed: {response.status}")
                    return False
        except Exception as e:
            print(f"‚ùå Authentication error: {e}")
            return False

    async def get_api_data(self, endpoint):
        """Generic method to fetch data from Proxmox API"""
        try:
            async with self.session.get(f"{self.base_url}/{endpoint}") as response:
                if response.status == 200:
                    return await response.json()
                else:
                    return None
        except Exception as e:
            return None

    def format_bytes(self, bytes_value):
        """Format bytes to human readable format"""
        if bytes_value is None:
            return "Unknown"
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if bytes_value < 1024.0:
                return f"{bytes_value:.2f} {unit}"
            bytes_value /= 1024.0
        return f"{bytes_value:.2f} PB"

    def create_backup_cleanup_script(self):
        """Create backup storage cleanup script"""
        script_content = """#!/bin/bash
# Proxmox Backup Storage Emergency Cleanup Script
# Generated by Proxmox Agent - High Priority Optimization

echo "üö® CRITICAL: Emergency Backup Storage Cleanup"
echo "============================================="

# Function to show backup storage usage
show_backup_usage() {
    echo "üìä Current backup storage usage:"
    df -h /var/lib/vz/dump 2>/dev/null || echo "Backup storage location not found at /var/lib/vz/dump"
    echo ""
}

echo "üìä BEFORE CLEANUP:"
show_backup_usage

# Find backup storage location
BACKUP_LOCATIONS=(
    "/var/lib/vz/dump"
    "/mnt/pve/Backups"
    "/Backups"
    "/backup"
)

BACKUP_DIR=""
for location in "${BACKUP_LOCATIONS[@]}"; do
    if [ -d "$location" ]; then
        BACKUP_DIR="$location"
        echo "‚úÖ Found backup directory: $BACKUP_DIR"
        break
    fi
done

if [ -z "$BACKUP_DIR" ]; then
    echo "‚ùå Could not locate backup directory. Please check manually."
    echo "Common locations:"
    for location in "${BACKUP_LOCATIONS[@]}"; do
        echo "   $location"
    done
    exit 1
fi

cd "$BACKUP_DIR" || exit 1

echo ""
echo "üîç Analyzing backup files in $BACKUP_DIR..."

# Show current backup files by age
echo "üìã Current backup files:"
ls -lhat *.{tar,tar.gz,tar.lzo,vma,vma.gz,vma.lzo} 2>/dev/null | head -20

echo ""
echo "üìä Backup files by size:"
du -sh *.{tar,tar.gz,tar.lzo,vma,vma.gz,vma.lzo} 2>/dev/null | sort -hr | head -10

echo ""
echo "üóëÔ∏è PHASE 1: Remove backups older than 60 days (SAFE)"
find . -name "*.tar.gz" -mtime +60 -ls
find . -name "*.tar.lzo" -mtime +60 -ls
find . -name "*.vma.gz" -mtime +60 -ls
find . -name "*.vma.lzo" -mtime +60 -ls

# Count files to be deleted
OLD_COUNT=$(find . -name "*.tar.gz" -mtime +60 | wc -l)
OLD_COUNT=$((OLD_COUNT + $(find . -name "*.tar.lzo" -mtime +60 | wc -l)))
OLD_COUNT=$((OLD_COUNT + $(find . -name "*.vma.gz" -mtime +60 | wc -l)))
OLD_COUNT=$((OLD_COUNT + $(find . -name "*.vma.lzo" -mtime +60 | wc -l)))

echo "üìä Files to delete (>60 days): $OLD_COUNT"

if [ $OLD_COUNT -gt 0 ]; then
    echo "üóëÔ∏è Deleting old backup files..."
    find . -name "*.tar.gz" -mtime +60 -delete
    find . -name "*.tar.lzo" -mtime +60 -delete  
    find . -name "*.vma.gz" -mtime +60 -delete
    find . -name "*.vma.lzo" -mtime +60 -delete
    echo "‚úÖ Deleted $OLD_COUNT old backup files"
else
    echo "‚ÑπÔ∏è No backups older than 60 days found"
fi

echo ""
show_backup_usage

echo ""
echo "üóëÔ∏è PHASE 2: Remove backup logs older than 30 days"
find . -name "*.log" -mtime +30 -delete 2>/dev/null
find . -name "*.tmp" -mtime +7 -delete 2>/dev/null

echo ""
show_backup_usage

# If still critical, suggest manual review
USAGE=$(df "$BACKUP_DIR" | awk 'NR==2 {print $5}' | sed 's/%//')
if [ "$USAGE" -gt 95 ]; then
    echo ""
    echo "‚ö†Ô∏è STILL CRITICAL: Backup storage still >95% full"
    echo "Manual review required:"
    echo ""
    echo "üìã Largest remaining files:"
    du -sh * 2>/dev/null | sort -hr | head -10
    echo ""
    echo "üîç Consider removing:"
    echo "   1. Backups older than 30 days (if safe for your retention policy)"
    echo "   2. Failed backup attempts"
    echo "   3. Temporary files"
    echo ""
    echo "‚ö†Ô∏è Commands for manual cleanup (USE WITH CAUTION):"
    echo "   find . -name '*.tar.gz' -mtime +30 -ls    # List 30+ day old backups"
    echo "   find . -name '*.tar.gz' -mtime +30 -delete # Delete 30+ day old backups"
elif [ "$USAGE" -gt 85 ]; then
    echo ""
    echo "üü° WARNING: Backup storage still high ($USAGE% full)"
    echo "Consider implementing automated retention policy"
else
    echo ""
    echo "‚úÖ SUCCESS: Backup storage usage now acceptable ($USAGE% full)"
fi

echo ""
echo "üìä FINAL BACKUP STORAGE STATUS:"
show_backup_usage

echo ""
echo "üéâ Backup cleanup completed!"
echo "üìã Next steps:"
echo "   1. Implement automated backup retention policy"
echo "   2. Monitor backup storage regularly"
echo "   3. Consider expanding backup storage if needed"
"""

        # Write the script
        with open('backup_storage_cleanup.sh', 'w') as f:
            f.write(script_content)
        
        # Make it executable
        os.chmod('backup_storage_cleanup.sh', 0o755)
        
        print("üíæ Created backup cleanup script: backup_storage_cleanup.sh")

    def create_snapshot_lifecycle_script(self):
        """Create automated snapshot lifecycle management script"""
        script_content = """#!/bin/bash
# Proxmox Automated Snapshot Lifecycle Management
# Generated by Proxmox Agent - High Priority Optimization

echo "üì∏ Automated Snapshot Lifecycle Management"
echo "=========================================="

# Configuration
KEEP_DAILY=7      # Keep 7 daily snapshots
KEEP_WEEKLY=4     # Keep 4 weekly snapshots  
KEEP_MONTHLY=12   # Keep 12 monthly snapshots

LOG_FILE="/var/log/snapshot-cleanup.log"
DATE=$(date '+%Y-%m-%d %H:%M:%S')

log_message() {
    echo "[$DATE] $1" | tee -a "$LOG_FILE"
}

log_message "Starting automated snapshot cleanup"

# Function to get snapshot age in days
get_snapshot_age_days() {
    local snapshot_time="$1"
    local current_time=$(date +%s)
    local age_seconds=$((current_time - snapshot_time))
    local age_days=$((age_seconds / 86400))
    echo $age_days
}

# Clean old VM snapshots
log_message "Processing VM snapshots..."
for vmid in $(qm list | awk 'NR>1 {print $1}'); do
    if qm config $vmid >/dev/null 2>&1; then
        log_message "Checking VM $vmid snapshots"
        
        # Get snapshots (excluding current)
        qm listsnapshot $vmid 2>/dev/null | grep -v current | grep -v NAME | while read snapshot_line; do
            snapshot_name=$(echo "$snapshot_line" | awk '{print $1}')
            snapshot_time=$(echo "$snapshot_line" | awk '{print $3}')
            
            if [ -n "$snapshot_time" ] && [ "$snapshot_time" != "0" ]; then
                age_days=$(get_snapshot_age_days "$snapshot_time")
                
                # Delete snapshots older than retention policy
                if [ $age_days -gt 90 ]; then
                    log_message "Deleting old VM $vmid snapshot '$snapshot_name' (${age_days} days old)"
                    qm delsnapshot $vmid "$snapshot_name" --force 2>/dev/null
                elif [ $age_days -gt 30 ]; then
                    log_message "VM $vmid snapshot '$snapshot_name' is ${age_days} days old (review recommended)"
                fi
            fi
        done
    fi
done

# Clean old container snapshots
log_message "Processing container snapshots..."
for ctid in $(pct list | awk 'NR>1 {print $1}'); do
    if pct config $ctid >/dev/null 2>&1; then
        log_message "Checking container $ctid snapshots"
        
        # Get snapshots (excluding current)
        pct listsnapshot $ctid 2>/dev/null | grep -v current | grep -v NAME | while read snapshot_line; do
            snapshot_name=$(echo "$snapshot_line" | awk '{print $1}')
            snapshot_time=$(echo "$snapshot_line" | awk '{print $3}')
            
            if [ -n "$snapshot_time" ] && [ "$snapshot_time" != "0" ]; then
                age_days=$(get_snapshot_age_days "$snapshot_time")
                
                # Delete snapshots older than retention policy
                if [ $age_days -gt 90 ]; then
                    log_message "Deleting old container $ctid snapshot '$snapshot_name' (${age_days} days old)"
                    pct delsnapshot $ctid "$snapshot_name" --force 2>/dev/null
                elif [ $age_days -gt 30 ]; then
                    log_message "Container $ctid snapshot '$snapshot_name' is ${age_days} days old (review recommended)"
                fi
            fi
        done
    fi
done

# Clean orphaned snapshot files
log_message "Cleaning orphaned snapshot files..."
find /var/lib/vz -name "*snapshot*" -mtime +90 -type f -delete 2>/dev/null

log_message "Snapshot cleanup completed"

# Report current snapshot count
TOTAL_SNAPSHOTS=0
for vmid in $(qm list | awk 'NR>1 {print $1}'); do
    VM_SNAPSHOTS=$(qm listsnapshot $vmid 2>/dev/null | grep -v current | grep -v NAME | wc -l)
    TOTAL_SNAPSHOTS=$((TOTAL_SNAPSHOTS + VM_SNAPSHOTS))
done

for ctid in $(pct list | awk 'NR>1 {print $1}'); do
    CT_SNAPSHOTS=$(pct listsnapshot $ctid 2>/dev/null | grep -v current | grep -v NAME | wc -l)
    TOTAL_SNAPSHOTS=$((TOTAL_SNAPSHOTS + CT_SNAPSHOTS))
done

log_message "Total remaining snapshots: $TOTAL_SNAPSHOTS"

echo "üìä Snapshot cleanup summary logged to: $LOG_FILE"
echo "üì∏ Current total snapshots: $TOTAL_SNAPSHOTS"
"""

        # Write the script
        with open('snapshot_lifecycle_management.sh', 'w') as f:
            f.write(script_content)
        
        # Make it executable
        os.chmod('snapshot_lifecycle_management.sh', 0o755)
        
        print("üíæ Created snapshot lifecycle script: snapshot_lifecycle_management.sh")

    def create_security_updates_script(self):
        """Create automated security updates configuration script"""
        script_content = """#!/bin/bash
# Proxmox Automated Security Updates Setup
# Generated by Proxmox Agent - High Priority Optimization

echo "üîí Setting up Automated Security Updates"
echo "========================================"

# Install unattended-upgrades if not present
if ! dpkg -l | grep -q unattended-upgrades; then
    echo "üì¶ Installing unattended-upgrades..."
    apt update
    apt install -y unattended-upgrades apt-listchanges
else
    echo "‚úÖ unattended-upgrades already installed"
fi

# Configure unattended-upgrades
echo "‚öôÔ∏è Configuring automated security updates..."

# Backup original config
cp /etc/apt/apt.conf.d/50unattended-upgrades /etc/apt/apt.conf.d/50unattended-upgrades.backup 2>/dev/null

# Create optimized configuration
cat > /etc/apt/apt.conf.d/50unattended-upgrades << 'EOF'
// Automatically upgrade packages from these (origin:archive) pairs
Unattended-Upgrade::Allowed-Origins {
    "${distro_id}:${distro_codename}";
    "${distro_id}:${distro_codename}-security";
    "${distro_id}:${distro_codename}-updates";
    "${distro_id}ESMApps:${distro_codename}-apps-security";
    "${distro_id}ESM:${distro_codename}-infra-security";
    "Proxmox:${distro_codename}";
};

// Python regular expressions, matching packages to exclude from upgrading
Unattended-Upgrade::Package-Blacklist {
    // Exclude kernel updates (require manual testing)
    "linux-.*";
    ".*-kernel-.*";
    
    // Exclude Proxmox packages that need manual testing
    "pve-kernel-.*";
    "proxmox-ve";
    "pve-manager";
};

// Send email to this address for problems or packages upgrades
Unattended-Upgrade::Mail "root";

// Set to true to get emails only on errors
Unattended-Upgrade::MailReport "on-change";

// Remove unused automatically installed kernel-related packages
Unattended-Upgrade::Remove-Unused-Kernel-Packages "true";

// Remove new unused dependencies after the upgrade
Unattended-Upgrade::Remove-New-Unused-Dependencies "true";

// Remove unused dependencies after the upgrade
Unattended-Upgrade::Remove-Unused-Dependencies "true";

// Automatically reboot *WITHOUT CONFIRMATION* if the file /var/run/reboot-required exists after the upgrade
Unattended-Upgrade::Automatic-Reboot "false";

// If automatic reboot is enabled, reboot at this time
Unattended-Upgrade::Automatic-Reboot-Time "02:00";

// Enable logging to syslog
Unattended-Upgrade::SyslogEnable "true";
EOF

# Configure auto-upgrades
echo "‚öôÔ∏è Enabling automatic security updates..."
cat > /etc/apt/apt.conf.d/20auto-upgrades << 'EOF'
APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Download-Upgradeable-Packages "1";
APT::Periodic::AutocleanInterval "7";
APT::Periodic::Unattended-Upgrade "1";
EOF

# Test the configuration
echo "üß™ Testing unattended-upgrades configuration..."
unattended-upgrades --dry-run --debug

# Set up container auto-updates (where appropriate)
echo ""
echo "üì¶ Setting up container security updates..."

# Create container update script
cat > /usr/local/bin/container-security-updates.sh << 'EOF'
#!/bin/bash
# Container Security Updates Script

LOG_FILE="/var/log/container-updates.log"
DATE=$(date '+%Y-%m-%d %H:%M:%S')

log_message() {
    echo "[$DATE] $1" | tee -a "$LOG_FILE"
}

# Safe containers for auto-updates (exclude databases and complex apps)
SAFE_CONTAINERS=(
    105  # nginxproxymanager
    107  # gotify
    109  # uptimekuma
    110  # homepage
    113  # lldap
    120  # alpine-it-tools
    125  # adguard
)

log_message "Starting container security updates"

for ctid in "${SAFE_CONTAINERS[@]}"; do
    if pct status $ctid | grep -q "running"; then
        log_message "Updating container $ctid"
        
        # Determine container OS and update accordingly
        if pct exec $ctid -- which apt >/dev/null 2>&1; then
            # Debian/Ubuntu based
            pct exec $ctid -- apt update
            pct exec $ctid -- apt upgrade -y
        elif pct exec $ctid -- which apk >/dev/null 2>&1; then
            # Alpine based
            pct exec $ctid -- apk update
            pct exec $ctid -- apk upgrade
        fi
        
        log_message "Completed updates for container $ctid"
    else
        log_message "Container $ctid is not running, skipping"
    fi
done

log_message "Container security updates completed"
EOF

chmod +x /usr/local/bin/container-security-updates.sh

# Add to cron (weekly container updates)
echo "‚è∞ Setting up automated schedules..."
cat > /etc/cron.d/security-updates << 'EOF'
# Proxmox Security Updates Automation
# Run container updates weekly on Sunday at 3 AM
0 3 * * 0 root /usr/local/bin/container-security-updates.sh
EOF

echo ""
echo "‚úÖ Automated security updates configured!"
echo ""
echo "üìã Summary:"
echo "   - Host security updates: Enabled (daily check)"
echo "   - Container updates: Weekly schedule (safe containers only)"
echo "   - Logs: /var/log/unattended-upgrades/ and /var/log/container-updates.log"
echo "   - Email notifications: Enabled for root user"
echo ""
echo "‚ö†Ô∏è Important notes:"
echo "   - Kernel updates excluded (require manual testing)"
echo "   - Complex containers (databases) excluded from auto-updates"
echo "   - No automatic reboots configured"
echo ""
echo "üîç Monitor with:"
echo "   cat /var/log/unattended-upgrades/unattended-upgrades.log"
echo "   cat /var/log/container-updates.log"
"""

        # Write the script
        with open('security_updates_setup.sh', 'w') as f:
            f.write(script_content)
        
        # Make it executable
        os.chmod('security_updates_setup.sh', 0o755)
        
        print("üíæ Created security updates script: security_updates_setup.sh")

    def create_storage_monitoring_script(self):
        """Create storage monitoring and alerting script"""
        script_content = """#!/bin/bash
# Proxmox Storage Monitoring and Alerting
# Generated by Proxmox Agent - High Priority Optimization

echo "üìä Setting up Storage Monitoring and Alerting"
echo "============================================="

# Create storage monitoring script
cat > /usr/local/bin/storage-monitor.sh << 'EOF'
#!/bin/bash
# Storage Monitoring Script

LOG_FILE="/var/log/storage-monitor.log"
DATE=$(date '+%Y-%m-%d %H:%M:%S')

log_message() {
    echo "[$DATE] $1" | tee -a "$LOG_FILE"
}

send_alert() {
    local message="$1"
    local severity="$2"
    
    # Log the alert
    log_message "ALERT [$severity]: $message"
    
    # Send email alert
    echo "$message" | mail -s "Proxmox Storage Alert [$severity] - $(hostname)" root
    
    # Send to gotify if available (CT 107)
    if pct status 107 | grep -q "running"; then
        # Get gotify container IP
        GOTIFY_IP=$(pct exec 107 -- hostname -I | awk '{print $1}')
        if [ -n "$GOTIFY_IP" ]; then
            curl -X POST "http://$GOTIFY_IP:80/message" \
                -H "Content-Type: application/json" \
                -d "{\"title\":\"Proxmox Storage Alert\",\"message\":\"$message\",\"priority\":5}" \
                2>/dev/null || true
        fi
    fi
}

check_filesystem() {
    local fs="$1"
    local threshold_warning="$2"
    local threshold_critical="$3"
    
    if [ ! -d "$fs" ]; then
        return
    fi
    
    local usage=$(df "$fs" | awk 'NR==2 {print $5}' | sed 's/%//')
    local used=$(df -h "$fs" | awk 'NR==2 {print $3}')
    local total=$(df -h "$fs" | awk 'NR==2 {print $2}')
    local avail=$(df -h "$fs" | awk 'NR==2 {print $4}')
    
    if [ "$usage" -ge "$threshold_critical" ]; then
        send_alert "CRITICAL: $fs is ${usage}% full (${used}/${total}, ${avail} available)" "CRITICAL"
    elif [ "$usage" -ge "$threshold_warning" ]; then
        send_alert "WARNING: $fs is ${usage}% full (${used}/${total}, ${avail} available)" "WARNING"
    fi
}

check_lvm_storage() {
    # Check LVM thin pools
    local lvm_usage=$(lvs --noheadings -o data_percent pve/data 2>/dev/null | tr -d ' %')
    
    if [ -n "$lvm_usage" ] && [ "$lvm_usage" -ge 90 ]; then
        send_alert "CRITICAL: LVM thin pool is ${lvm_usage}% full" "CRITICAL"
    elif [ -n "$lvm_usage" ] && [ "$lvm_usage" -ge 80 ]; then
        send_alert "WARNING: LVM thin pool is ${lvm_usage}% full" "WARNING"
    fi
}

# Monitor key filesystems
log_message "Starting storage monitoring check"

# Root filesystem
check_filesystem "/" 80 90

# Local storage
check_filesystem "/var/lib/vz" 80 90

# Backup storage  
check_filesystem "/var/lib/vz/dump" 85 95
check_filesystem "/mnt/pve/Backups" 85 95

# Check LVM storage
check_lvm_storage

# Check for snapshot storage issues
SNAPSHOT_COUNT=0
for vmid in $(qm list | awk 'NR>1 {print $1}'); do
    VM_SNAPSHOTS=$(qm listsnapshot $vmid 2>/dev/null | grep -v current | grep -v NAME | wc -l)
    SNAPSHOT_COUNT=$((SNAPSHOT_COUNT + VM_SNAPSHOTS))
done

for ctid in $(pct list | awk 'NR>1 {print $1}'); do
    CT_SNAPSHOTS=$(pct listsnapshot $ctid 2>/dev/null | grep -v current | grep -v NAME | wc -l)
    SNAPSHOT_COUNT=$((SNAPSHOT_COUNT + CT_SNAPSHOTS))
done

if [ "$SNAPSHOT_COUNT" -gt 100 ]; then
    send_alert "WARNING: High snapshot count detected ($SNAPSHOT_COUNT total). Consider cleanup." "WARNING"
fi

log_message "Storage monitoring check completed"
EOF

chmod +x /usr/local/bin/storage-monitor.sh

# Create comprehensive storage status script
cat > /usr/local/bin/storage-status.sh << 'EOF'
#!/bin/bash
# Comprehensive Storage Status Report

echo "üìä PROXMOX STORAGE STATUS REPORT"
echo "================================"
echo "üìÖ Generated: $(date)"
echo ""

echo "üíø FILESYSTEM USAGE:"
echo "-------------------"
df -h / /var/lib/vz 2>/dev/null | grep -v tmpfs

echo ""
echo "üíæ LVM STORAGE POOLS:"
echo "--------------------"
pvesm status 2>/dev/null || echo "PVE storage manager not available"

echo ""
echo "üì∏ SNAPSHOT SUMMARY:"
echo "-------------------"
TOTAL_SNAPSHOTS=0

for vmid in $(qm list | awk 'NR>1 {print $1}'); do
    VM_SNAPSHOTS=$(qm listsnapshot $vmid 2>/dev/null | grep -v current | grep -v NAME | wc -l)
    if [ $VM_SNAPSHOTS -gt 0 ]; then
        echo "VM $vmid: $VM_SNAPSHOTS snapshots"
    fi
    TOTAL_SNAPSHOTS=$((TOTAL_SNAPSHOTS + VM_SNAPSHOTS))
done

for ctid in $(pct list | awk 'NR>1 {print $1}'); do
    CT_SNAPSHOTS=$(pct listsnapshot $ctid 2>/dev/null | grep -v current | grep -v NAME | wc -l)
    if [ $CT_SNAPSHOTS -gt 0 ]; then
        echo "CT $ctid: $CT_SNAPSHOTS snapshots"
    fi
    TOTAL_SNAPSHOTS=$((TOTAL_SNAPSHOTS + CT_SNAPSHOTS))
done

echo "Total snapshots: $TOTAL_SNAPSHOTS"

echo ""
echo "üîç LARGE FILES (>1GB):"
echo "---------------------"
find /var/lib/vz -size +1G -type f -exec ls -lh {} \; 2>/dev/null | head -10

echo ""
echo "‚úÖ Storage status report completed"
EOF

chmod +x /usr/local/bin/storage-status.sh

# Set up cron jobs for monitoring
echo "‚è∞ Setting up monitoring schedule..."
cat > /etc/cron.d/storage-monitoring << 'EOF'
# Proxmox Storage Monitoring
# Check storage every 6 hours
0 */6 * * * root /usr/local/bin/storage-monitor.sh

# Generate daily storage report
0 8 * * * root /usr/local/bin/storage-status.sh | mail -s "Daily Storage Report - $(hostname)" root
EOF

echo ""
echo "‚úÖ Storage monitoring configured!"
echo ""
echo "üìã Monitoring setup:"
echo "   - Storage checks: Every 6 hours"
echo "   - Daily reports: 8 AM via email"
echo "   - Gotify alerts: Enabled (if CT 107 running)"
echo "   - Log file: /var/log/storage-monitor.log"
echo ""
echo "üîç Manual commands:"
echo "   /usr/local/bin/storage-monitor.sh    # Run check now"
echo "   /usr/local/bin/storage-status.sh     # Generate report"
echo "   tail -f /var/log/storage-monitor.log # Monitor alerts"
"""

        # Write the script
        with open('storage_monitoring_setup.sh', 'w') as f:
            f.write(script_content)
        
        # Make it executable
        os.chmod('storage_monitoring_setup.sh', 0o755)
        
        print("üíæ Created storage monitoring script: storage_monitoring_setup.sh")

    async def execute_optimizations(self):
        """Execute the high priority optimizations"""
        print("üöÄ IMPLEMENTING HIGH PRIORITY OPTIMIZATIONS")
        print("="*60)
        print(f"üìÖ Implementation Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"üñ•Ô∏è  Target: {self.host}:{self.port}")
        
        try:
            await self.create_session()
            
            print("\nüîê Authenticating with Proxmox...")
            if not await self.authenticate():
                return False
                
            print("‚úÖ Authentication successful")
            
            # Generate all optimization scripts
            print("\nüìù Creating optimization scripts...")
            print("-" * 40)
            
            self.create_backup_cleanup_script()
            self.create_snapshot_lifecycle_script()
            self.create_security_updates_script()
            self.create_storage_monitoring_script()
            
            print("\n‚úÖ All optimization scripts created!")
            
            # Create execution instructions
            execution_instructions = f"""
# HIGH PRIORITY OPTIMIZATION EXECUTION INSTRUCTIONS
# Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## üö® CRITICAL - Execute these in order:

### 1. BACKUP STORAGE CLEANUP (IMMEDIATE)
scp backup_storage_cleanup.sh root@{self.host}:/tmp/
ssh root@{self.host} "chmod +x /tmp/backup_storage_cleanup.sh && /tmp/backup_storage_cleanup.sh"

### 2. SNAPSHOT LIFECYCLE MANAGEMENT
scp snapshot_lifecycle_management.sh root@{self.host}:/tmp/
ssh root@{self.host} "chmod +x /tmp/snapshot_lifecycle_management.sh && /tmp/snapshot_lifecycle_management.sh"

### 3. SECURITY UPDATES AUTOMATION
scp security_updates_setup.sh root@{self.host}:/tmp/
ssh root@{self.host} "chmod +x /tmp/security_updates_setup.sh && /tmp/security_updates_setup.sh"

### 4. STORAGE MONITORING & ALERTING
scp storage_monitoring_setup.sh root@{self.host}:/tmp/
ssh root@{self.host} "chmod +x /tmp/storage_monitoring_setup.sh && /tmp/storage_monitoring_setup.sh"

## üìä Verification Commands:
ssh root@{self.host} "df -h"                                    # Check storage
ssh root@{self.host} "systemctl status unattended-upgrades"     # Check auto-updates
ssh root@{self.host} "crontab -l"                              # Check scheduled tasks
ssh root@{self.host} "/usr/local/bin/storage-status.sh"        # Storage report

## üéØ Expected Results:
- Backup storage: <80% utilization
- Automated snapshot cleanup: Configured
- Security updates: Enabled with safe exclusions  
- Storage monitoring: Active with 6-hour checks
"""
            
            with open('EXECUTE_HIGH_PRIORITY_OPTIMIZATIONS.txt', 'w') as f:
                f.write(execution_instructions)
            
            print(f"\nüìã IMPLEMENTATION SUMMARY")
            print("="*40)
            print("‚úÖ Backup storage cleanup script ready")
            print("‚úÖ Snapshot lifecycle management ready")
            print("‚úÖ Security updates automation ready")
            print("‚úÖ Storage monitoring & alerting ready")
            print()
            print("üìÅ Files created:")
            print("   - backup_storage_cleanup.sh")
            print("   - snapshot_lifecycle_management.sh")
            print("   - security_updates_setup.sh")
            print("   - storage_monitoring_setup.sh")
            print("   - EXECUTE_HIGH_PRIORITY_OPTIMIZATIONS.txt")
            print()
            print("‚ö° NEXT STEP: Execute the commands in EXECUTE_HIGH_PRIORITY_OPTIMIZATIONS.txt")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Optimization implementation failed: {e}")
            return False
        finally:
            if self.session:
                await self.session.close()

async def main():
    """Main function"""
    optimizer = HighPriorityOptimizations()
    success = await optimizer.execute_optimizations()
    
    if success:
        print("\nüéâ High priority optimization scripts created successfully!")
        print("üëâ Follow the instructions in EXECUTE_HIGH_PRIORITY_OPTIMIZATIONS.txt")
    else:
        print("\nüí• Optimization implementation failed!")
        sys.exit(1)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nüõë Implementation interrupted by user")
    except Exception as e:
        print(f"\nüí• Unexpected error: {e}")
        sys.exit(1)